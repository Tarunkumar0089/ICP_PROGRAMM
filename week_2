Question 2696. Minimum String Length After Removing Substrings
https://leetcode.com/problems/minimum-string-length-after-removing-substrings/description/
class Solution {
    public int minLength(String s) {
        Stack<Character> st = new Stack<>();
        for(int i=0;i<s.length();i++){
            char ch = s.charAt(i);
            st.push(ch);
            if(st.size()>=2){
                char ch1 = st.pop();
                char ch2 = st.peek();
                if((ch1=='B' && ch2=='A') ||(ch1=='D' && ch2=='C')){
                    st.pop();
                }
                else{
                    st.push(ch1);
                }
            }
        }
        int n = st.size();
        return n;
    }
}

Question 1544. Make The String Great.
https://leetcode.com/problems/make-the-string-great/description/
class Solution {
    public String makeGood(String s) {
        Stack<Character> st = new Stack<>();
        for(int i=0;i<s.length();i++){
            char ch = s.charAt(i);
            st.push(ch);
            if(st.size()>=2){
                char ch1 = st.pop();
                char ch2 = st.peek();
                
                if(Math.abs(ch1-ch2)==32){
                    st.pop();
                }
                else{
                    st.push(ch1);
                }
            }
        }
        StringBuilder sb = new StringBuilder();
        while(!st.isEmpty()){
            sb.append(st.pop());
        }
        return sb.reverse().toString();
    }
}


Question 907. Sum of Subarray Minimums
https://leetcode.com/problems/sum-of-subarray-minimums/description/
class Solution {
    public int sumSubarrayMins(int[] arr) {
        Stack<Integer> st = new Stack<>();
        int n = arr.length;
        int nsl[] = new int[n];
        int nsr[] = new int[n];
        for(int i=0;i<arr.length;i++){
            while(!st.isEmpty() && arr[i]<arr[st.peek()]){
                st.pop();
            }
            if(st.isEmpty()){
                nsl[i] = -1;
            }
            else{
                nsl[i] = st.peek();
            }
            st.push(i);
        }
        st.clear();
        for(int i=arr.length-1;i>=0;i--){
            while(!st.isEmpty() && arr[i]<=arr[st.peek()]){
                st.pop();
            }
            if(st.isEmpty()){
                nsr[i] = n;
            }
            else{
                nsr[i] = st.peek();
            }
            st.push(i);
        }
        long sum =0;
        int mod = 1000000007;
        for(int i=0;i<arr.length;i++){
            long nl = i-nsl[i];
            long nr = nsr[i] - i;
            long totalway = nl*nr;
            long totalsum = arr[i]*totalway;
            sum = (sum+totalsum)%mod;
        }
        return (int) sum;
    }
}

Question 1856. Maximum Subarray Min-Product
https://leetcode.com/problems/maximum-subarray-min-product/description/
class Solution {
    public int maxSumMinProduct(int[] nums) {
        Stack<Integer> st = new Stack<>();
        int n = nums.length;
        int nsl[] = new int[n];
        int nsr[] = new int[n];
        for(int i=0;i<nums.length;i++){
            while(!st.isEmpty() && nums[i]<=nums[st.peek()]){
                st.pop();
            }
            if(st.isEmpty()){
                nsl[i] = -1;
            }
            else{
                nsl[i] = st.peek();
            }
            st.push(i);
        }
        st.clear();
        for(int i=nums.length-1;i>=0;i--){
            while(!st.isEmpty() && nums[i]<=nums[st.peek()]){
                st.pop();
            }
            if(st.isEmpty()){
                nsr[i] = n;
            }
            else{
                nsr[i] = st.peek();
            }
            st.push(i);
        }
        long prefix[] = new long[n];
        prefix[0] = nums[0];
        for(int i=1;i<n;i++){
            prefix[i]=prefix[i-1]+nums[i];
        }
        long max = 0;
        long mod = 1000000007;
        for(int i=0;i<n;i++){
            int nl = nsl[i];
            int nr = nsr[i];
            long subsum;
            if(nl==-1){
                subsum = prefix[nr-1];
            }
            else{
                subsum = prefix[nr-1]-prefix[nl];
            }
            max = Math.max(max,subsum*nums[i]);
        }
        return (int)(max%mod);
    }
}
