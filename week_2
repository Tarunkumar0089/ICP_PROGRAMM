Question 2696. Minimum String Length After Removing Substrings
https://leetcode.com/problems/minimum-string-length-after-removing-substrings/submissions/1889524676
class Solution {
    public int minLength(String s) {
        Stack<Character> st = new Stack<>();
        for(int i=0;i<s.length();i++){
            char ch = s.charAt(i);
            st.push(ch);
            if(st.size()>=2){
                char ch1 = st.pop();
                char ch2 = st.peek();
                if((ch1=='B' && ch2=='A') ||(ch1=='D' && ch2=='C')){
                    st.pop();
                }
                else{
                    st.push(ch1);
                }
            }
        }
        int n = st.size();
        return n;
    }
}

Question 1544. Make The String Great.
https://leetcode.com/problems/make-the-string-great/submissions/1889536903
class Solution {
    public String makeGood(String s) {
        Stack<Character> st = new Stack<>();
        for(int i=0;i<s.length();i++){
            char ch = s.charAt(i);
            st.push(ch);
            if(st.size()>=2){
                char ch1 = st.pop();
                char ch2 = st.peek();
                
                if(Math.abs(ch1-ch2)==32){
                    st.pop();
                }
                else{
                    st.push(ch1);
                }
            }
        }
        StringBuilder sb = new StringBuilder();
        while(!st.isEmpty()){
            sb.append(st.pop());
        }
        return sb.reverse().toString();
    }
}


Question 907. Sum of Subarray Minimums
https://leetcode.com/problems/sum-of-subarray-minimums/submissions/1889595991
class Solution {
    public int sumSubarrayMins(int[] arr) {
        int n=arr.length;
        int mod=1000000007;
        int left[] =new int[n];
        int right[] =new int[n];

        Stack<int[]>st1=new Stack<>();
        Stack<int[]>st2=new Stack<>();

        for(int i=0;i<n;i++){
           while(!st1.isEmpty()&& arr[i]<=st1.peek()[0]){
            st1.pop();
           }
           left[i]=st1.isEmpty()?-1:st1.peek()[1];
           st1.push(new int[]{arr[i],i});
        }

        for(int i=n-1;i>=0;i--){
           while(!st2.isEmpty()&& arr[i]<st2.peek()[0]){
            st2.pop();
           }
           right[i]=st2.isEmpty()?n:st2.peek()[1];
           st2.push(new int[]{arr[i],i});
        } 

        long sum=0;
        for(int i=0;i<n;i++){
            long l=i-left[i];
            long r=right[i]-i;
            long curr=arr[i]*(l*r);
            sum+=curr;
        }
        return (int)(sum%mod);
    }
}

Question 1856. Maximum Subarray Min-Product
https://leetcode.com/problems/maximum-subarray-min-product/submissions/1890704994
class Solution {
    public int maxSumMinProduct(int[] nums) {
        Stack<int[]>st1=new Stack<>();
        Stack<int[]>st2=new Stack<>();
        int n=nums.length;
        int mod=1000000007;
        
        int [] left=new int[nums.length];
        int right[] =new int[nums.length];
        for(int i=0;i<n;i++){
           while(!st1.isEmpty()&& nums[i]<=st1.peek()[0]){
            st1.pop();
           }
           left[i]=st1.isEmpty()?-1:st1.peek()[1];
           st1.push(new int[]{nums[i],i});
        }
        for(int i=n-1;i>=0;i--){
           while(!st2.isEmpty()&& nums[i]<=st2.peek()[0]){
            st2.pop();
           }
           right[i]=st2.isEmpty()?n:st2.peek()[1];
           st2.push(new int[]{nums[i],i});
        } 
        long[] prefix = new long[n];
        prefix[0]=nums[0];
        for (int i = 1; i < n; i++) {
            prefix[i]=prefix[i-1]+nums[i];
        }
        long max=0;
        for(int i=0;i<nums.length;i++){
         long l=left[i]<0?0:prefix[left[i]]; 
         long r=prefix[right[i]-1]; 
         max=Math.max(max,(long)nums[i]*(r-l));
        }
        return (int)(max%mod);
    }
}
1526. Minimum Number of Increments on Subarrays to Form a Target Array
https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/submissions/1891756410
class Solution {
    public int minNumberOperations(int[] target) {
        int ans=target[0];
        for(int i=1;i<target.length;i++){
             if(target[i]>target[i-1]){
                ans+=target[i]-target[i-1];
             }
        }
        return ans;
    }
}

2030. Smallest K-Length Subsequence With Occurrences of a Letter
https://leetcode.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/submissions/1891987911

class Solution {
    public String smallestSubsequence(String s, int k, char letter, int r) {
       int n_letters=0;
       for(int i=0;i<s.length();i++){
        if(s.charAt(i)==letter){
            n_letters++;
        }
       }
        Stack<Character>st=new Stack<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            while(!st.isEmpty() && st.peek()>c &&(s.length()-i +(st.size()-1)>=k) && (st.peek() != letter|| n_letters > r)){
                if(st.pop()==letter) r++;
            }
            if (st.size() < k) {
                if (c == letter) {
                    st.push(c);
                    r --;
                } else if (k - st.size() > r) {
                    st.push(c);
                }
            }
            if (c == letter) n_letters --;
        }
       
       StringBuilder sb=new StringBuilder(st.size());
       for(Character c:st) sb.append(c);
        return  sb.toString();
    }
}

